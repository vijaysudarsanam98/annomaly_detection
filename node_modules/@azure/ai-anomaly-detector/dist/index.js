'use strict';

Object.defineProperty(exports, '__esModule', { value: true });

var tslib = require('tslib');
var coreHttp = require('@azure/core-http');
require('@azure/core-paging');
var coreTracing = require('@azure/core-tracing');
var logger$1 = require('@azure/logger');

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const createSpan = coreTracing.createSpanFunction({
    namespace: "Microsoft.CognitiveServices",
    packagePrefix: "Azure.CognitiveServices.AnomalyDetector"
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const DetectRequest = {
    type: {
        name: "Composite",
        className: "DetectRequest",
        modelProperties: {
            series: {
                serializedName: "series",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TimeSeriesPoint"
                        }
                    }
                }
            },
            granularity: {
                serializedName: "granularity",
                type: {
                    name: "Enum",
                    allowedValues: [
                        "yearly",
                        "monthly",
                        "weekly",
                        "daily",
                        "hourly",
                        "minutely",
                        "secondly",
                        "microsecond",
                        "none"
                    ]
                }
            },
            customInterval: {
                serializedName: "customInterval",
                type: {
                    name: "Number"
                }
            },
            period: {
                serializedName: "period",
                type: {
                    name: "Number"
                }
            },
            maxAnomalyRatio: {
                serializedName: "maxAnomalyRatio",
                type: {
                    name: "Number"
                }
            },
            sensitivity: {
                serializedName: "sensitivity",
                type: {
                    name: "Number"
                }
            },
            imputeMode: {
                serializedName: "imputeMode",
                type: {
                    name: "String"
                }
            },
            imputeFixedValue: {
                serializedName: "imputeFixedValue",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const TimeSeriesPoint = {
    type: {
        name: "Composite",
        className: "TimeSeriesPoint",
        modelProperties: {
            timestamp: {
                serializedName: "timestamp",
                type: {
                    name: "DateTime"
                }
            },
            value: {
                serializedName: "value",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DetectEntireResponse = {
    type: {
        name: "Composite",
        className: "DetectEntireResponse",
        modelProperties: {
            period: {
                serializedName: "period",
                required: true,
                type: {
                    name: "Number"
                }
            },
            expectedValues: {
                serializedName: "expectedValues",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            upperMargins: {
                serializedName: "upperMargins",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            lowerMargins: {
                serializedName: "lowerMargins",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            isAnomaly: {
                serializedName: "isAnomaly",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Boolean"
                        }
                    }
                }
            },
            isNegativeAnomaly: {
                serializedName: "isNegativeAnomaly",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Boolean"
                        }
                    }
                }
            },
            isPositiveAnomaly: {
                serializedName: "isPositiveAnomaly",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Boolean"
                        }
                    }
                }
            },
            severity: {
                serializedName: "severity",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            }
        }
    }
};
const AnomalyDetectorError = {
    type: {
        name: "Composite",
        className: "AnomalyDetectorError",
        modelProperties: {
            code: {
                serializedName: "code",
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DetectLastPointResponse = {
    type: {
        name: "Composite",
        className: "DetectLastPointResponse",
        modelProperties: {
            period: {
                serializedName: "period",
                required: true,
                type: {
                    name: "Number"
                }
            },
            suggestedWindow: {
                serializedName: "suggestedWindow",
                required: true,
                type: {
                    name: "Number"
                }
            },
            expectedValue: {
                serializedName: "expectedValue",
                required: true,
                type: {
                    name: "Number"
                }
            },
            upperMargin: {
                serializedName: "upperMargin",
                required: true,
                type: {
                    name: "Number"
                }
            },
            lowerMargin: {
                serializedName: "lowerMargin",
                required: true,
                type: {
                    name: "Number"
                }
            },
            isAnomaly: {
                serializedName: "isAnomaly",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            isNegativeAnomaly: {
                serializedName: "isNegativeAnomaly",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            isPositiveAnomaly: {
                serializedName: "isPositiveAnomaly",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            severity: {
                serializedName: "severity",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DetectChangePointRequest = {
    type: {
        name: "Composite",
        className: "DetectChangePointRequest",
        modelProperties: {
            series: {
                serializedName: "series",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "TimeSeriesPoint"
                        }
                    }
                }
            },
            granularity: {
                serializedName: "granularity",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: [
                        "yearly",
                        "monthly",
                        "weekly",
                        "daily",
                        "hourly",
                        "minutely",
                        "secondly",
                        "microsecond",
                        "none"
                    ]
                }
            },
            customInterval: {
                serializedName: "customInterval",
                type: {
                    name: "Number"
                }
            },
            period: {
                serializedName: "period",
                type: {
                    name: "Number"
                }
            },
            stableTrendWindow: {
                serializedName: "stableTrendWindow",
                type: {
                    name: "Number"
                }
            },
            threshold: {
                serializedName: "threshold",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const DetectChangePointResponse = {
    type: {
        name: "Composite",
        className: "DetectChangePointResponse",
        modelProperties: {
            period: {
                serializedName: "period",
                readOnly: true,
                type: {
                    name: "Number"
                }
            },
            isChangePoint: {
                serializedName: "isChangePoint",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Boolean"
                        }
                    }
                }
            },
            confidenceScores: {
                serializedName: "confidenceScores",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            }
        }
    }
};
const ModelInfo = {
    type: {
        name: "Composite",
        className: "ModelInfo",
        modelProperties: {
            slidingWindow: {
                serializedName: "slidingWindow",
                type: {
                    name: "Number"
                }
            },
            alignPolicy: {
                serializedName: "alignPolicy",
                type: {
                    name: "Composite",
                    className: "AlignPolicy"
                }
            },
            source: {
                serializedName: "source",
                required: true,
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            displayName: {
                constraints: {
                    MaxLength: 24
                },
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            status: {
                serializedName: "status",
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["CREATED", "RUNNING", "READY", "FAILED"]
                }
            },
            errors: {
                serializedName: "errors",
                readOnly: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorResponse"
                        }
                    }
                }
            },
            diagnosticsInfo: {
                serializedName: "diagnosticsInfo",
                type: {
                    name: "Composite",
                    className: "DiagnosticsInfo"
                }
            }
        }
    }
};
const AlignPolicy = {
    type: {
        name: "Composite",
        className: "AlignPolicy",
        modelProperties: {
            alignMode: {
                serializedName: "alignMode",
                type: {
                    name: "Enum",
                    allowedValues: ["Inner", "Outer"]
                }
            },
            fillNAMethod: {
                serializedName: "fillNAMethod",
                type: {
                    name: "String"
                }
            },
            paddingValue: {
                serializedName: "paddingValue",
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const ErrorResponse = {
    type: {
        name: "Composite",
        className: "ErrorResponse",
        modelProperties: {
            code: {
                serializedName: "code",
                required: true,
                type: {
                    name: "String"
                }
            },
            message: {
                serializedName: "message",
                required: true,
                type: {
                    name: "String"
                }
            }
        }
    }
};
const DiagnosticsInfo = {
    type: {
        name: "Composite",
        className: "DiagnosticsInfo",
        modelProperties: {
            modelState: {
                serializedName: "modelState",
                type: {
                    name: "Composite",
                    className: "ModelState"
                }
            },
            variableStates: {
                serializedName: "variableStates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VariableState"
                        }
                    }
                }
            }
        }
    }
};
const ModelState = {
    type: {
        name: "Composite",
        className: "ModelState",
        modelProperties: {
            epochIds: {
                serializedName: "epochIds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            trainLosses: {
                serializedName: "trainLosses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            validationLosses: {
                serializedName: "validationLosses",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            },
            latenciesInSeconds: {
                serializedName: "latenciesInSeconds",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            }
        }
    }
};
const VariableState = {
    type: {
        name: "Composite",
        className: "VariableState",
        modelProperties: {
            variable: {
                serializedName: "variable",
                type: {
                    name: "String"
                }
            },
            filledNARatio: {
                constraints: {
                    InclusiveMaximum: 1,
                    InclusiveMinimum: 0
                },
                serializedName: "filledNARatio",
                type: {
                    name: "Number"
                }
            },
            effectiveCount: {
                serializedName: "effectiveCount",
                type: {
                    name: "Number"
                }
            },
            startTime: {
                serializedName: "startTime",
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const ModelList = {
    type: {
        name: "Composite",
        className: "ModelList",
        modelProperties: {
            models: {
                serializedName: "models",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ModelSnapshot"
                        }
                    }
                }
            },
            currentCount: {
                serializedName: "currentCount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            maxCount: {
                serializedName: "maxCount",
                required: true,
                type: {
                    name: "Number"
                }
            },
            nextLink: {
                serializedName: "nextLink",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const ModelSnapshot = {
    type: {
        name: "Composite",
        className: "ModelSnapshot",
        modelProperties: {
            modelId: {
                serializedName: "modelId",
                required: true,
                type: {
                    name: "Uuid"
                }
            },
            createdTime: {
                serializedName: "createdTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            lastUpdatedTime: {
                serializedName: "lastUpdatedTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            status: {
                serializedName: "status",
                required: true,
                readOnly: true,
                type: {
                    name: "Enum",
                    allowedValues: ["CREATED", "RUNNING", "READY", "FAILED"]
                }
            },
            displayName: {
                serializedName: "displayName",
                type: {
                    name: "String"
                }
            },
            variablesCount: {
                serializedName: "variablesCount",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const Model = {
    type: {
        name: "Composite",
        className: "Model",
        modelProperties: {
            modelId: {
                serializedName: "modelId",
                required: true,
                type: {
                    name: "Uuid"
                }
            },
            createdTime: {
                serializedName: "createdTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            lastUpdatedTime: {
                serializedName: "lastUpdatedTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            modelInfo: {
                serializedName: "modelInfo",
                type: {
                    name: "Composite",
                    className: "ModelInfo"
                }
            }
        }
    }
};
const DetectionRequest = {
    type: {
        name: "Composite",
        className: "DetectionRequest",
        modelProperties: {
            source: {
                serializedName: "source",
                required: true,
                type: {
                    name: "String"
                }
            },
            startTime: {
                serializedName: "startTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            endTime: {
                serializedName: "endTime",
                required: true,
                type: {
                    name: "DateTime"
                }
            }
        }
    }
};
const DetectionResult = {
    type: {
        name: "Composite",
        className: "DetectionResult",
        modelProperties: {
            resultId: {
                serializedName: "resultId",
                required: true,
                type: {
                    name: "Uuid"
                }
            },
            summary: {
                serializedName: "summary",
                type: {
                    name: "Composite",
                    className: "DetectionResultSummary"
                }
            },
            results: {
                serializedName: "results",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AnomalyState"
                        }
                    }
                }
            }
        }
    }
};
const DetectionResultSummary = {
    type: {
        name: "Composite",
        className: "DetectionResultSummary",
        modelProperties: {
            status: {
                serializedName: "status",
                required: true,
                type: {
                    name: "Enum",
                    allowedValues: ["CREATED", "RUNNING", "READY", "FAILED"]
                }
            },
            errors: {
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorResponse"
                        }
                    }
                }
            },
            variableStates: {
                serializedName: "variableStates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VariableState"
                        }
                    }
                }
            },
            setupInfo: {
                serializedName: "setupInfo",
                type: {
                    name: "Composite",
                    className: "DetectionRequest"
                }
            }
        }
    }
};
const AnomalyState = {
    type: {
        name: "Composite",
        className: "AnomalyState",
        modelProperties: {
            timestamp: {
                serializedName: "timestamp",
                required: true,
                type: {
                    name: "DateTime"
                }
            },
            value: {
                serializedName: "value",
                type: {
                    name: "Composite",
                    className: "AnomalyValue"
                }
            },
            errors: {
                serializedName: "errors",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "ErrorResponse"
                        }
                    }
                }
            }
        }
    }
};
const AnomalyValue = {
    type: {
        name: "Composite",
        className: "AnomalyValue",
        modelProperties: {
            isAnomaly: {
                serializedName: "isAnomaly",
                required: true,
                type: {
                    name: "Boolean"
                }
            },
            severity: {
                constraints: {
                    InclusiveMaximum: 1,
                    InclusiveMinimum: 0
                },
                serializedName: "severity",
                required: true,
                type: {
                    name: "Number"
                }
            },
            score: {
                constraints: {
                    InclusiveMaximum: 2,
                    InclusiveMinimum: 0
                },
                serializedName: "score",
                required: true,
                type: {
                    name: "Number"
                }
            },
            interpretation: {
                serializedName: "interpretation",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AnomalyInterpretation"
                        }
                    }
                }
            }
        }
    }
};
const AnomalyInterpretation = {
    type: {
        name: "Composite",
        className: "AnomalyInterpretation",
        modelProperties: {
            variable: {
                serializedName: "variable",
                type: {
                    name: "String"
                }
            },
            contributionScore: {
                serializedName: "contributionScore",
                type: {
                    name: "Number"
                }
            },
            correlationChanges: {
                serializedName: "correlationChanges",
                type: {
                    name: "Composite",
                    className: "CorrelationChanges"
                }
            }
        }
    }
};
const CorrelationChanges = {
    type: {
        name: "Composite",
        className: "CorrelationChanges",
        modelProperties: {
            changedVariables: {
                serializedName: "changedVariables",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            changedValues: {
                serializedName: "changedValues",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            }
        }
    }
};
const LastDetectionRequest = {
    type: {
        name: "Composite",
        className: "LastDetectionRequest",
        modelProperties: {
            variables: {
                serializedName: "variables",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VariableValues"
                        }
                    }
                }
            },
            detectingPoints: {
                serializedName: "detectingPoints",
                required: true,
                type: {
                    name: "Number"
                }
            }
        }
    }
};
const VariableValues = {
    type: {
        name: "Composite",
        className: "VariableValues",
        modelProperties: {
            name: {
                serializedName: "name",
                required: true,
                type: {
                    name: "String"
                }
            },
            timestamps: {
                serializedName: "timestamps",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "String"
                        }
                    }
                }
            },
            values: {
                serializedName: "values",
                required: true,
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Number"
                        }
                    }
                }
            }
        }
    }
};
const LastDetectionResult = {
    type: {
        name: "Composite",
        className: "LastDetectionResult",
        modelProperties: {
            variableStates: {
                serializedName: "variableStates",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "VariableState"
                        }
                    }
                }
            },
            results: {
                serializedName: "results",
                type: {
                    name: "Sequence",
                    element: {
                        type: {
                            name: "Composite",
                            className: "AnomalyState"
                        }
                    }
                }
            }
        }
    }
};
const AnomalyDetectorDetectEntireSeriesExceptionHeaders = {
    type: {
        name: "Composite",
        className: "AnomalyDetectorDetectEntireSeriesExceptionHeaders",
        modelProperties: {
            xMsErrorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AnomalyDetectorDetectLastPointExceptionHeaders = {
    type: {
        name: "Composite",
        className: "AnomalyDetectorDetectLastPointExceptionHeaders",
        modelProperties: {
            xMsErrorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AnomalyDetectorDetectChangePointExceptionHeaders = {
    type: {
        name: "Composite",
        className: "AnomalyDetectorDetectChangePointExceptionHeaders",
        modelProperties: {
            xMsErrorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AnomalyDetectorTrainMultivariateModelHeaders = {
    type: {
        name: "Composite",
        className: "AnomalyDetectorTrainMultivariateModelHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AnomalyDetectorTrainMultivariateModelExceptionHeaders = {
    type: {
        name: "Composite",
        className: "AnomalyDetectorTrainMultivariateModelExceptionHeaders",
        modelProperties: {
            xMsErrorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AnomalyDetectorListMultivariateModelExceptionHeaders = {
    type: {
        name: "Composite",
        className: "AnomalyDetectorListMultivariateModelExceptionHeaders",
        modelProperties: {
            xMsErrorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AnomalyDetectorGetMultivariateModelExceptionHeaders = {
    type: {
        name: "Composite",
        className: "AnomalyDetectorGetMultivariateModelExceptionHeaders",
        modelProperties: {
            xMsErrorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AnomalyDetectorDeleteMultivariateModelExceptionHeaders = {
    type: {
        name: "Composite",
        className: "AnomalyDetectorDeleteMultivariateModelExceptionHeaders",
        modelProperties: {
            xMsErrorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AnomalyDetectorDetectAnomalyHeaders = {
    type: {
        name: "Composite",
        className: "AnomalyDetectorDetectAnomalyHeaders",
        modelProperties: {
            location: {
                serializedName: "location",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AnomalyDetectorDetectAnomalyExceptionHeaders = {
    type: {
        name: "Composite",
        className: "AnomalyDetectorDetectAnomalyExceptionHeaders",
        modelProperties: {
            xMsErrorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AnomalyDetectorGetDetectionResultExceptionHeaders = {
    type: {
        name: "Composite",
        className: "AnomalyDetectorGetDetectionResultExceptionHeaders",
        modelProperties: {
            xMsErrorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AnomalyDetectorExportModelExceptionHeaders = {
    type: {
        name: "Composite",
        className: "AnomalyDetectorExportModelExceptionHeaders",
        modelProperties: {
            xMsErrorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AnomalyDetectorLastDetectAnomalyExceptionHeaders = {
    type: {
        name: "Composite",
        className: "AnomalyDetectorLastDetectAnomalyExceptionHeaders",
        modelProperties: {
            xMsErrorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};
const AnomalyDetectorListMultivariateModelNextExceptionHeaders = {
    type: {
        name: "Composite",
        className: "AnomalyDetectorListMultivariateModelNextExceptionHeaders",
        modelProperties: {
            xMsErrorCode: {
                serializedName: "x-ms-error-code",
                type: {
                    name: "String"
                }
            }
        }
    }
};

var Mappers = /*#__PURE__*/Object.freeze({
    __proto__: null,
    DetectRequest: DetectRequest,
    TimeSeriesPoint: TimeSeriesPoint,
    DetectEntireResponse: DetectEntireResponse,
    AnomalyDetectorError: AnomalyDetectorError,
    DetectLastPointResponse: DetectLastPointResponse,
    DetectChangePointRequest: DetectChangePointRequest,
    DetectChangePointResponse: DetectChangePointResponse,
    ModelInfo: ModelInfo,
    AlignPolicy: AlignPolicy,
    ErrorResponse: ErrorResponse,
    DiagnosticsInfo: DiagnosticsInfo,
    ModelState: ModelState,
    VariableState: VariableState,
    ModelList: ModelList,
    ModelSnapshot: ModelSnapshot,
    Model: Model,
    DetectionRequest: DetectionRequest,
    DetectionResult: DetectionResult,
    DetectionResultSummary: DetectionResultSummary,
    AnomalyState: AnomalyState,
    AnomalyValue: AnomalyValue,
    AnomalyInterpretation: AnomalyInterpretation,
    CorrelationChanges: CorrelationChanges,
    LastDetectionRequest: LastDetectionRequest,
    VariableValues: VariableValues,
    LastDetectionResult: LastDetectionResult,
    AnomalyDetectorDetectEntireSeriesExceptionHeaders: AnomalyDetectorDetectEntireSeriesExceptionHeaders,
    AnomalyDetectorDetectLastPointExceptionHeaders: AnomalyDetectorDetectLastPointExceptionHeaders,
    AnomalyDetectorDetectChangePointExceptionHeaders: AnomalyDetectorDetectChangePointExceptionHeaders,
    AnomalyDetectorTrainMultivariateModelHeaders: AnomalyDetectorTrainMultivariateModelHeaders,
    AnomalyDetectorTrainMultivariateModelExceptionHeaders: AnomalyDetectorTrainMultivariateModelExceptionHeaders,
    AnomalyDetectorListMultivariateModelExceptionHeaders: AnomalyDetectorListMultivariateModelExceptionHeaders,
    AnomalyDetectorGetMultivariateModelExceptionHeaders: AnomalyDetectorGetMultivariateModelExceptionHeaders,
    AnomalyDetectorDeleteMultivariateModelExceptionHeaders: AnomalyDetectorDeleteMultivariateModelExceptionHeaders,
    AnomalyDetectorDetectAnomalyHeaders: AnomalyDetectorDetectAnomalyHeaders,
    AnomalyDetectorDetectAnomalyExceptionHeaders: AnomalyDetectorDetectAnomalyExceptionHeaders,
    AnomalyDetectorGetDetectionResultExceptionHeaders: AnomalyDetectorGetDetectionResultExceptionHeaders,
    AnomalyDetectorExportModelExceptionHeaders: AnomalyDetectorExportModelExceptionHeaders,
    AnomalyDetectorLastDetectAnomalyExceptionHeaders: AnomalyDetectorLastDetectAnomalyExceptionHeaders,
    AnomalyDetectorListMultivariateModelNextExceptionHeaders: AnomalyDetectorListMultivariateModelNextExceptionHeaders
});

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const contentType = {
    parameterPath: ["options", "contentType"],
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Content-Type",
        type: {
            name: "String"
        }
    }
};
const body = {
    parameterPath: "body",
    mapper: DetectRequest
};
const accept = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const endpoint = {
    parameterPath: "endpoint",
    mapper: {
        serializedName: "Endpoint",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const apiVersion = {
    parameterPath: "apiVersion",
    mapper: {
        defaultValue: "v1.1-preview.1",
        isConstant: true,
        serializedName: "ApiVersion",
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};
const body1 = {
    parameterPath: "body",
    mapper: DetectChangePointRequest
};
const body2 = {
    parameterPath: "body",
    mapper: ModelInfo
};
const skip = {
    parameterPath: ["options", "skip"],
    mapper: {
        serializedName: "$skip",
        type: {
            name: "Number"
        }
    }
};
const top = {
    parameterPath: ["options", "top"],
    mapper: {
        defaultValue: 5,
        serializedName: "$top",
        type: {
            name: "Number"
        }
    }
};
const modelId = {
    parameterPath: "modelId",
    mapper: {
        serializedName: "modelId",
        required: true,
        type: {
            name: "Uuid"
        }
    }
};
const body3 = {
    parameterPath: "body",
    mapper: DetectionRequest
};
const resultId = {
    parameterPath: "resultId",
    mapper: {
        serializedName: "resultId",
        required: true,
        type: {
            name: "Uuid"
        }
    }
};
const accept1 = {
    parameterPath: "accept",
    mapper: {
        defaultValue: "application/zip, application/json",
        isConstant: true,
        serializedName: "Accept",
        type: {
            name: "String"
        }
    }
};
const body4 = {
    parameterPath: "body",
    mapper: LastDetectionRequest
};
const nextLink = {
    parameterPath: "nextLink",
    mapper: {
        serializedName: "nextLink",
        required: true,
        type: {
            name: "String"
        }
    },
    skipEncoding: true
};

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
const packageName = "@azure/ai-form-recognizer";
const packageVersion = "3.0.0-beta.5";
class AnomalyDetectorContext extends coreHttp.ServiceClient {
    /**
     * Initializes a new instance of the AnomalyDetectorContext class.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *                 https://westus2.api.cognitive.microsoft.com).
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        if (endpoint === undefined) {
            throw new Error("'endpoint' cannot be null");
        }
        // Initializing default values for options
        if (!options) {
            options = {};
        }
        const defaultUserAgent = `azsdk-js-${packageName.replace("@azure/", "")}/${packageVersion} ${coreHttp.getDefaultUserAgentValue()}`;
        super(undefined, Object.assign(Object.assign({}, options), { userAgent: options.userAgent
                ? `${options.userAgent} ${defaultUserAgent}`
                : `${defaultUserAgent}` }));
        this.requestContentType = "application/json; charset=utf-8";
        this.baseUri =
            options.endpoint || "{Endpoint}/anomalydetector/{ApiVersion}";
        // Parameter assignments
        this.endpoint = endpoint;
        // Assigning values to Constant parameters
        this.apiVersion = options.apiVersion || "v1.1-preview.1";
    }
}

/*
 * Copyright (c) Microsoft Corporation.
 * Licensed under the MIT License.
 *
 * Code generated by Microsoft (R) AutoRest Code Generator.
 * Changes may cause incorrect behavior and will be lost if the code is regenerated.
 */
/// <reference lib="esnext.asynciterable" />
class AnomalyDetector extends AnomalyDetectorContext {
    /**
     * Initializes a new instance of the AnomalyDetector class.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *                 https://westus2.api.cognitive.microsoft.com).
     * @param options The parameter options
     */
    constructor(endpoint, options) {
        super(endpoint, options);
    }
    /**
     * List models of a subscription
     * @param options The options parameters.
     */
    listMultivariateModel(options) {
        const iter = this.listMultivariateModelPagingAll(options);
        return {
            next() {
                return iter.next();
            },
            [Symbol.asyncIterator]() {
                return this;
            },
            byPage: () => {
                return this.listMultivariateModelPagingPage(options);
            }
        };
    }
    listMultivariateModelPagingPage(options) {
        return tslib.__asyncGenerator(this, arguments, function* listMultivariateModelPagingPage_1() {
            let result = yield tslib.__await(this._listMultivariateModel(options));
            yield yield tslib.__await(result.models || []);
            let continuationToken = result.nextLink;
            while (continuationToken) {
                result = yield tslib.__await(this._listMultivariateModelNext(continuationToken, options));
                continuationToken = result.nextLink;
                yield yield tslib.__await(result.models || []);
            }
        });
    }
    listMultivariateModelPagingAll(options) {
        return tslib.__asyncGenerator(this, arguments, function* listMultivariateModelPagingAll_1() {
            var e_1, _a;
            try {
                for (var _b = tslib.__asyncValues(this.listMultivariateModelPagingPage(options)), _c; _c = yield tslib.__await(_b.next()), !_c.done;) {
                    const page = _c.value;
                    yield tslib.__await(yield* tslib.__asyncDelegator(tslib.__asyncValues(page)));
                }
            }
            catch (e_1_1) { e_1 = { error: e_1_1 }; }
            finally {
                try {
                    if (_c && !_c.done && (_a = _b.return)) yield tslib.__await(_a.call(_b));
                }
                finally { if (e_1) throw e_1.error; }
            }
        });
    }
    /**
     * This operation generates a model with an entire series, each point is detected with the same model.
     * With this method, points before and after a certain point are used to determine whether it is an
     * anomaly. The entire detection can give user an overall status of the time series.
     * @param body Time series points and period if needed. Advanced model parameters can also be set in
     *             the request.
     * @param options The options parameters.
     */
    async detectEntireSeries(body, options) {
        const { span } = createSpan("AnomalyDetector-detectEntireSeries", options || {});
        const operationArguments = {
            body,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        try {
            const result = await this.sendOperationRequest(operationArguments, detectEntireSeriesOperationSpec);
            return result;
        }
        catch (error) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.UNSET,
                message: error.message
            });
            throw error;
        }
        finally {
            span.end();
        }
    }
    /**
     * This operation generates a model using points before the latest one. With this method, only
     * historical points are used to determine whether the target point is an anomaly. The latest point
     * detecting operation matches the scenario of real-time monitoring of business metrics.
     * @param body Time series points and period if needed. Advanced model parameters can also be set in
     *             the request.
     * @param options The options parameters.
     */
    async detectLastPoint(body, options) {
        const { span } = createSpan("AnomalyDetector-detectLastPoint", options || {});
        const operationArguments = {
            body,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        try {
            const result = await this.sendOperationRequest(operationArguments, detectLastPointOperationSpec);
            return result;
        }
        catch (error) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.UNSET,
                message: error.message
            });
            throw error;
        }
        finally {
            span.end();
        }
    }
    /**
     * Evaluate change point score of every series point
     * @param body Time series points and granularity is needed. Advanced model parameters can also be set
     *             in the request if needed.
     * @param options The options parameters.
     */
    async detectChangePoint(body, options) {
        const { span } = createSpan("AnomalyDetector-detectChangePoint", options || {});
        const operationArguments = {
            body,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        try {
            const result = await this.sendOperationRequest(operationArguments, detectChangePointOperationSpec);
            return result;
        }
        catch (error) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.UNSET,
                message: error.message
            });
            throw error;
        }
        finally {
            span.end();
        }
    }
    /**
     * Create and train a multivariate anomaly detection model. The request must include a source parameter
     * to indicate an externally accessible Azure storage Uri (preferably a Shared Access Signature Uri).
     * All time-series used in generate the model must be zipped into one single file. Each time-series
     * will be in a single CSV file in which the first column is timestamp and the second column is value.
     * @param body Training request
     * @param options The options parameters.
     */
    async trainMultivariateModel(body, options) {
        const { span } = createSpan("AnomalyDetector-trainMultivariateModel", options || {});
        const operationArguments = {
            body,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        try {
            const result = await this.sendOperationRequest(operationArguments, trainMultivariateModelOperationSpec);
            return result;
        }
        catch (error) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.UNSET,
                message: error.message
            });
            throw error;
        }
        finally {
            span.end();
        }
    }
    /**
     * List models of a subscription
     * @param options The options parameters.
     */
    async _listMultivariateModel(options) {
        const { span } = createSpan("AnomalyDetector-_listMultivariateModel", options || {});
        const operationArguments = {
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        try {
            const result = await this.sendOperationRequest(operationArguments, listMultivariateModelOperationSpec);
            return result;
        }
        catch (error) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.UNSET,
                message: error.message
            });
            throw error;
        }
        finally {
            span.end();
        }
    }
    /**
     * Get detailed information of multivariate model, including the training status and variables used in
     * the model.
     * @param modelId Model identifier.
     * @param options The options parameters.
     */
    async getMultivariateModel(modelId, options) {
        const { span } = createSpan("AnomalyDetector-getMultivariateModel", options || {});
        const operationArguments = {
            modelId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        try {
            const result = await this.sendOperationRequest(operationArguments, getMultivariateModelOperationSpec);
            return result;
        }
        catch (error) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.UNSET,
                message: error.message
            });
            throw error;
        }
        finally {
            span.end();
        }
    }
    /**
     * Delete an existing multivariate model according to the modelId
     * @param modelId Model identifier.
     * @param options The options parameters.
     */
    async deleteMultivariateModel(modelId, options) {
        const { span } = createSpan("AnomalyDetector-deleteMultivariateModel", options || {});
        const operationArguments = {
            modelId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        try {
            const result = await this.sendOperationRequest(operationArguments, deleteMultivariateModelOperationSpec);
            return result;
        }
        catch (error) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.UNSET,
                message: error.message
            });
            throw error;
        }
        finally {
            span.end();
        }
    }
    /**
     * Submit detection multivariate anomaly task with the trained model of modelId, the input schema
     * should be the same with the training request. Thus request will be complete asynchronously and will
     * return a resultId for querying the detection result.The request should be a source link to indicate
     * an externally accessible Azure storage Uri (preferably a Shared Access Signature Uri). All
     * time-series used in generate the model must be zipped into one single file. Each time-series will be
     * as follows: the first column is timestamp and the second column is value.
     * @param modelId Model identifier.
     * @param body Detect anomaly request
     * @param options The options parameters.
     */
    async detectAnomaly(modelId, body, options) {
        const { span } = createSpan("AnomalyDetector-detectAnomaly", options || {});
        const operationArguments = {
            modelId,
            body,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        try {
            const result = await this.sendOperationRequest(operationArguments, detectAnomalyOperationSpec);
            return result;
        }
        catch (error) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.UNSET,
                message: error.message
            });
            throw error;
        }
        finally {
            span.end();
        }
    }
    /**
     * Get multivariate anomaly detection result based on resultId returned by the DetectAnomalyAsync api
     * @param resultId Result identifier.
     * @param options The options parameters.
     */
    async getDetectionResult(resultId, options) {
        const { span } = createSpan("AnomalyDetector-getDetectionResult", options || {});
        const operationArguments = {
            resultId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        try {
            const result = await this.sendOperationRequest(operationArguments, getDetectionResultOperationSpec);
            return result;
        }
        catch (error) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.UNSET,
                message: error.message
            });
            throw error;
        }
        finally {
            span.end();
        }
    }
    /**
     * Export multivariate anomaly detection model based on modelId
     * @param modelId Model identifier.
     * @param options The options parameters.
     */
    async exportModel(modelId, options) {
        const { span } = createSpan("AnomalyDetector-exportModel", options || {});
        const operationArguments = {
            modelId,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        try {
            const result = await this.sendOperationRequest(operationArguments, exportModelOperationSpec);
            return result;
        }
        catch (error) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.UNSET,
                message: error.message
            });
            throw error;
        }
        finally {
            span.end();
        }
    }
    /**
     * Synchronized API for anomaly detection.
     * @param modelId Model identifier.
     * @param body Request for last detection.
     * @param options The options parameters.
     */
    async lastDetectAnomaly(modelId, body, options) {
        const { span } = createSpan("AnomalyDetector-lastDetectAnomaly", options || {});
        const operationArguments = {
            modelId,
            body,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        try {
            const result = await this.sendOperationRequest(operationArguments, lastDetectAnomalyOperationSpec);
            return result;
        }
        catch (error) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.UNSET,
                message: error.message
            });
            throw error;
        }
        finally {
            span.end();
        }
    }
    /**
     * ListMultivariateModelNext
     * @param nextLink The nextLink from the previous successful call to the ListMultivariateModel method.
     * @param options The options parameters.
     */
    async _listMultivariateModelNext(nextLink, options) {
        const { span } = createSpan("AnomalyDetector-_listMultivariateModelNext", options || {});
        const operationArguments = {
            nextLink,
            options: coreHttp.operationOptionsToRequestOptionsBase(options || {})
        };
        try {
            const result = await this.sendOperationRequest(operationArguments, listMultivariateModelNextOperationSpec);
            return result;
        }
        catch (error) {
            span.setStatus({
                code: coreTracing.SpanStatusCode.UNSET,
                message: error.message
            });
            throw error;
        }
        finally {
            span.end();
        }
    }
}
// Operation Specifications
const serializer = new coreHttp.Serializer(Mappers, /* isXml */ false);
const detectEntireSeriesOperationSpec = {
    path: "/timeseries/entire/detect",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DetectEntireResponse
        },
        default: {
            bodyMapper: AnomalyDetectorError,
            headersMapper: AnomalyDetectorDetectEntireSeriesExceptionHeaders
        }
    },
    requestBody: body,
    urlParameters: [endpoint, apiVersion],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const detectLastPointOperationSpec = {
    path: "/timeseries/last/detect",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DetectLastPointResponse
        },
        default: {
            bodyMapper: AnomalyDetectorError,
            headersMapper: AnomalyDetectorDetectLastPointExceptionHeaders
        }
    },
    requestBody: body,
    urlParameters: [endpoint, apiVersion],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const detectChangePointOperationSpec = {
    path: "/timeseries/changepoint/detect",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: DetectChangePointResponse
        },
        default: {
            bodyMapper: AnomalyDetectorError,
            headersMapper: AnomalyDetectorDetectChangePointExceptionHeaders
        }
    },
    requestBody: body1,
    urlParameters: [endpoint, apiVersion],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const trainMultivariateModelOperationSpec = {
    path: "/multivariate/models",
    httpMethod: "POST",
    responses: {
        201: {
            headersMapper: AnomalyDetectorTrainMultivariateModelHeaders
        },
        default: {
            bodyMapper: ErrorResponse,
            headersMapper: AnomalyDetectorTrainMultivariateModelExceptionHeaders
        }
    },
    requestBody: body2,
    urlParameters: [endpoint, apiVersion],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const listMultivariateModelOperationSpec = {
    path: "/multivariate/models",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ModelList
        },
        default: {
            bodyMapper: ErrorResponse,
            headersMapper: AnomalyDetectorListMultivariateModelExceptionHeaders
        }
    },
    queryParameters: [skip, top],
    urlParameters: [endpoint, apiVersion],
    headerParameters: [accept],
    serializer
};
const getMultivariateModelOperationSpec = {
    path: "/multivariate/models/{modelId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: Model
        },
        default: {
            bodyMapper: ErrorResponse,
            headersMapper: AnomalyDetectorGetMultivariateModelExceptionHeaders
        }
    },
    urlParameters: [
        endpoint,
        apiVersion,
        modelId
    ],
    headerParameters: [accept],
    serializer
};
const deleteMultivariateModelOperationSpec = {
    path: "/multivariate/models/{modelId}",
    httpMethod: "DELETE",
    responses: {
        204: {},
        default: {
            bodyMapper: ErrorResponse,
            headersMapper: AnomalyDetectorDeleteMultivariateModelExceptionHeaders
        }
    },
    urlParameters: [
        endpoint,
        apiVersion,
        modelId
    ],
    headerParameters: [accept],
    serializer
};
const detectAnomalyOperationSpec = {
    path: "/multivariate/models/{modelId}/detect",
    httpMethod: "POST",
    responses: {
        201: {
            headersMapper: AnomalyDetectorDetectAnomalyHeaders
        },
        default: {
            bodyMapper: ErrorResponse,
            headersMapper: AnomalyDetectorDetectAnomalyExceptionHeaders
        }
    },
    requestBody: body3,
    urlParameters: [
        endpoint,
        apiVersion,
        modelId
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const getDetectionResultOperationSpec = {
    path: "/multivariate/results/{resultId}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: DetectionResult
        },
        default: {
            bodyMapper: ErrorResponse,
            headersMapper: AnomalyDetectorGetDetectionResultExceptionHeaders
        }
    },
    urlParameters: [
        endpoint,
        apiVersion,
        resultId
    ],
    headerParameters: [accept],
    serializer
};
const exportModelOperationSpec = {
    path: "/multivariate/models/{modelId}/export",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: { type: { name: "Stream" }, serializedName: "parsedResponse" }
        },
        default: {
            bodyMapper: ErrorResponse,
            headersMapper: AnomalyDetectorExportModelExceptionHeaders
        }
    },
    urlParameters: [
        endpoint,
        apiVersion,
        modelId
    ],
    headerParameters: [accept1],
    serializer
};
const lastDetectAnomalyOperationSpec = {
    path: "/multivariate/models/{modelId}/last/detect",
    httpMethod: "POST",
    responses: {
        200: {
            bodyMapper: LastDetectionResult
        },
        default: {
            bodyMapper: ErrorResponse,
            headersMapper: AnomalyDetectorLastDetectAnomalyExceptionHeaders
        }
    },
    requestBody: body4,
    urlParameters: [
        endpoint,
        apiVersion,
        modelId
    ],
    headerParameters: [contentType, accept],
    mediaType: "json",
    serializer
};
const listMultivariateModelNextOperationSpec = {
    path: "{nextLink}",
    httpMethod: "GET",
    responses: {
        200: {
            bodyMapper: ModelList
        },
        default: {
            bodyMapper: ErrorResponse,
            headersMapper: AnomalyDetectorListMultivariateModelNextExceptionHeaders
        }
    },
    queryParameters: [skip, top],
    urlParameters: [
        endpoint,
        apiVersion,
        nextLink
    ],
    headerParameters: [accept],
    serializer
};

// Copyright (c) Microsoft Corporation.
// Licensed under the MIT license.
const SDK_VERSION = "3.0.0-beta.5";
const DEFAULT_COGNITIVE_SCOPE = "https://cognitiveservices.azure.com/.default";
const AnomalyDetectorLoggingAllowedHeaderNames = [
    "apim-request-id",
    "Location",
    "Operation-Location",
    "Strict-Transport-Security",
    "X-Content-Type-Options",
    "x-envoy-upstream-service-time",
    "Ocp-Apim-Subscription-Key",
];
const AnomalyDetectorLoggingAllowedQueryParameters = [
    "includeTextDetails",
    "includeKeys",
    "op",
];

// Copyright (c) Microsoft Corporation.
const API_KEY_HEADER_NAME = "Ocp-Apim-Subscription-Key";
/**
 * Create an HTTP pipeline policy to authenticate a request
 * using an `AzureKeyCredential` for Azure Anomaly Detector
 */
function createAnomalyDetectorAzureKeyCredentialPolicy(credential) {
    return {
        create: (nextPolicy, options) => {
            return new AnomalyDetectorAzureKeyCredentialPolicy(nextPolicy, options, credential);
        },
    };
}
/**
 * A concrete implementation of an AzureKeyCredential policy
 * using the appropriate header for Azure Anomaly Detector
 */
class AnomalyDetectorAzureKeyCredentialPolicy extends coreHttp.BaseRequestPolicy {
    constructor(nextPolicy, options, credential) {
        super(nextPolicy, options);
        this.credential = credential;
    }
    async sendRequest(webResource) {
        webResource.headers.set(API_KEY_HEADER_NAME, this.credential.key);
        return this._nextPolicy.sendRequest(webResource);
    }
}

// Copyright (c) Microsoft Corporation.
/**
 * The \@azure/logger configuration for this package.
 */
const logger = logger$1.createClientLogger("ai-anomaly-detector");

// Copyright (c) Microsoft Corporation.
/**
 * Client class for interacting with Azure Anomaly Detector service.
 */
class AnomalyDetectorClient extends AnomalyDetector {
    /**
     * Creates an instance of AnomalyDetectorClient.
     *
     * Example usage:
     * ```ts
     * import { AnomalyDetectorClient, AzureKeyCredential } from "@azure/ai-anomaly-detector";
     *
     * const client = new AnomalyDetectorClient(
     *    "<service endpoint>",
     *    new AzureKeyCredential("<api key>")
     * );
     * ```
     * @param endpointUrl - Url to an Azure Anomaly Detector service endpoint
     * @param credential - Used to authenticate requests to the service.
     * @param options - Used to configure the Form Recognizer client.
     */
    constructor(endpointUrl, credential, 
    /* eslint-disable-next-line @azure/azure-sdk/ts-naming-options */
    options) {
        const pipelineOptions = tslib.__rest(options, []);
        const libInfo = `azsdk-js-ai-anomalydetector/${SDK_VERSION}`;
        if (!pipelineOptions.userAgentOptions) {
            pipelineOptions.userAgentOptions = {};
        }
        if (pipelineOptions.userAgentOptions.userAgentPrefix) {
            pipelineOptions.userAgentOptions.userAgentPrefix = `${pipelineOptions.userAgentOptions.userAgentPrefix} ${libInfo}`;
        }
        else {
            pipelineOptions.userAgentOptions.userAgentPrefix = libInfo;
        }
        const authPolicy = coreHttp.isTokenCredential(credential)
            ? coreHttp.bearerTokenAuthenticationPolicy(credential, DEFAULT_COGNITIVE_SCOPE)
            : createAnomalyDetectorAzureKeyCredentialPolicy(credential);
        const internalPipelineOptions = Object.assign(Object.assign({}, pipelineOptions), {
            loggingOptions: {
                logger: logger.info,
                allowedHeaderNames: AnomalyDetectorLoggingAllowedHeaderNames,
                allowedQueryParameters: AnomalyDetectorLoggingAllowedQueryParameters,
            },
        });
        const pipeline = coreHttp.createPipelineFromOptions(internalPipelineOptions, authPolicy);
        super(endpointUrl, pipeline);
    }
}

// Copyright (c) Microsoft Corporation.
(function (KnownTimeGranularity) {
    /**
     * Yearly time granularity
     */
    KnownTimeGranularity["yearly"] = "yearly";
    /**
     * Monthly time granularity
     */
    KnownTimeGranularity["monthly"] = "monthly";
    /**
     * Weekly time granularity
     */
    KnownTimeGranularity["weekly"] = "weekly";
    /**
     * Daily time granularity
     */
    KnownTimeGranularity["daily"] = "daily";
    /**
     * Hourly time granularity
     */
    KnownTimeGranularity["hourly"] = "hourly";
    /**
     * Per minute time granularity
     */
    KnownTimeGranularity["perMinute"] = "minutely";
    /**
     * Per second time granularity
     */
    KnownTimeGranularity["perSecond"] = "secondly";
    /**
     * Per microsecond time granularity
     */
    KnownTimeGranularity["perMicrosecond"] = "microsecond";
    /**
     * None
     */
    KnownTimeGranularity["none"] = "none";
})(exports.KnownTimeGranularity || (exports.KnownTimeGranularity = {}));

exports.AnomalyDetector = AnomalyDetector;
exports.AnomalyDetectorClient = AnomalyDetectorClient;
exports.AnomalyDetectorContext = AnomalyDetectorContext;
//# sourceMappingURL=index.js.map
