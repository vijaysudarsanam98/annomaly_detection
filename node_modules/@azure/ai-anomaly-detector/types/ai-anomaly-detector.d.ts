/// <reference types="node" />

import * as coreHttp from '@azure/core-http';
import { KeyCredential } from '@azure/core-auth';
import { PagedAsyncIterableIterator } from '@azure/core-paging';
import { PipelineOptions } from '@azure/core-http';
import { TokenCredential } from '@azure/core-auth';

/** Defines values for AlignMode. */
export declare type AlignMode = "Inner" | "Outer";

export declare interface AlignPolicy {
    /** An optional field, indicating how we align different variables to the same time-range. Either Inner or Outer. */
    alignMode?: AlignMode;
    /** An optional field, indicating how missing values will be filled. One of Previous, Subsequent, Linear, Zero, Fixed, and NotFill. Cannot be set to NotFill, when the alignMode is Outer. */
    fillNAMethod?: FillNAMethod;
    /** An optional field. Required when fillNAMethod is Fixed. */
    paddingValue?: number;
}

export declare class AnomalyDetector extends AnomalyDetectorContext {
    /**
     * Initializes a new instance of the AnomalyDetector class.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *                 https://westus2.api.cognitive.microsoft.com).
     * @param options The parameter options
     */
    constructor(endpoint: string, options?: AnomalyDetectorOptionalParams);
    /**
     * List models of a subscription
     * @param options The options parameters.
     */
    listMultivariateModel(options?: AnomalyDetectorListMultivariateModelOptionalParams): PagedAsyncIterableIterator<AnomalyDetectorClientModelSnapshot>;
    private listMultivariateModelPagingPage;
    private listMultivariateModelPagingAll;
    /**
     * This operation generates a model with an entire series, each point is detected with the same model.
     * With this method, points before and after a certain point are used to determine whether it is an
     * anomaly. The entire detection can give user an overall status of the time series.
     * @param body Time series points and period if needed. Advanced model parameters can also be set in
     *             the request.
     * @param options The options parameters.
     */
    detectEntireSeries(body: DetectRequest, options?: AnomalyDetectorDetectEntireSeriesOptionalParams): Promise<AnomalyDetectorDetectEntireSeriesResponse>;
    /**
     * This operation generates a model using points before the latest one. With this method, only
     * historical points are used to determine whether the target point is an anomaly. The latest point
     * detecting operation matches the scenario of real-time monitoring of business metrics.
     * @param body Time series points and period if needed. Advanced model parameters can also be set in
     *             the request.
     * @param options The options parameters.
     */
    detectLastPoint(body: DetectRequest, options?: AnomalyDetectorDetectLastPointOptionalParams): Promise<AnomalyDetectorDetectLastPointResponse>;
    /**
     * Evaluate change point score of every series point
     * @param body Time series points and granularity is needed. Advanced model parameters can also be set
     *             in the request if needed.
     * @param options The options parameters.
     */
    detectChangePoint(body: DetectChangePointRequest, options?: AnomalyDetectorDetectChangePointOptionalParams): Promise<AnomalyDetectorDetectChangePointResponse>;
    /**
     * Create and train a multivariate anomaly detection model. The request must include a source parameter
     * to indicate an externally accessible Azure storage Uri (preferably a Shared Access Signature Uri).
     * All time-series used in generate the model must be zipped into one single file. Each time-series
     * will be in a single CSV file in which the first column is timestamp and the second column is value.
     * @param body Training request
     * @param options The options parameters.
     */
    trainMultivariateModel(body: AnomalyDetectorClientModelInfo, options?: AnomalyDetectorTrainMultivariateModelOptionalParams): Promise<AnomalyDetectorTrainMultivariateModelResponse>;
    /**
     * List models of a subscription
     * @param options The options parameters.
     */
    private _listMultivariateModel;
    /**
     * Get detailed information of multivariate model, including the training status and variables used in
     * the model.
     * @param modelId Model identifier.
     * @param options The options parameters.
     */
    getMultivariateModel(modelId: string, options?: AnomalyDetectorGetMultivariateModelOptionalParams): Promise<AnomalyDetectorGetMultivariateModelResponse>;
    /**
     * Delete an existing multivariate model according to the modelId
     * @param modelId Model identifier.
     * @param options The options parameters.
     */
    deleteMultivariateModel(modelId: string, options?: AnomalyDetectorDeleteMultivariateModelOptionalParams): Promise<coreHttp.RestResponse>;
    /**
     * Submit detection multivariate anomaly task with the trained model of modelId, the input schema
     * should be the same with the training request. Thus request will be complete asynchronously and will
     * return a resultId for querying the detection result.The request should be a source link to indicate
     * an externally accessible Azure storage Uri (preferably a Shared Access Signature Uri). All
     * time-series used in generate the model must be zipped into one single file. Each time-series will be
     * as follows: the first column is timestamp and the second column is value.
     * @param modelId Model identifier.
     * @param body Detect anomaly request
     * @param options The options parameters.
     */
    detectAnomaly(modelId: string, body: DetectionRequest, options?: AnomalyDetectorDetectAnomalyOptionalParams): Promise<AnomalyDetectorDetectAnomalyResponse>;
    /**
     * Get multivariate anomaly detection result based on resultId returned by the DetectAnomalyAsync api
     * @param resultId Result identifier.
     * @param options The options parameters.
     */
    getDetectionResult(resultId: string, options?: AnomalyDetectorGetDetectionResultOptionalParams): Promise<AnomalyDetectorGetDetectionResultResponse>;
    /**
     * Export multivariate anomaly detection model based on modelId
     * @param modelId Model identifier.
     * @param options The options parameters.
     */
    exportModel(modelId: string, options?: AnomalyDetectorExportModelOptionalParams): Promise<AnomalyDetectorExportModelResponse>;
    /**
     * Synchronized API for anomaly detection.
     * @param modelId Model identifier.
     * @param body Request for last detection.
     * @param options The options parameters.
     */
    lastDetectAnomaly(modelId: string, body: LastDetectionRequest, options?: AnomalyDetectorLastDetectAnomalyOptionalParams): Promise<AnomalyDetectorLastDetectAnomalyResponse>;
    /**
     * ListMultivariateModelNext
     * @param nextLink The nextLink from the previous successful call to the ListMultivariateModel method.
     * @param options The options parameters.
     */
    private _listMultivariateModelNext;
}

/**
 * Client class for interacting with Azure Anomaly Detector service.
 */
export declare class AnomalyDetectorClient extends AnomalyDetector {
    /**
     * Creates an instance of AnomalyDetectorClient.
     *
     * Example usage:
     * ```ts
     * import { AnomalyDetectorClient, AzureKeyCredential } from "@azure/ai-anomaly-detector";
     *
     * const client = new AnomalyDetectorClient(
     *    "<service endpoint>",
     *    new AzureKeyCredential("<api key>")
     * );
     * ```
     * @param endpointUrl - Url to an Azure Anomaly Detector service endpoint
     * @param credential - Used to authenticate requests to the service.
     * @param options - Used to configure the Form Recognizer client.
     */
    constructor(endpointUrl: string, credential: TokenCredential | KeyCredential, options?: PipelineOptions);
}

export declare interface AnomalyDetectorClientErrorResponse {
    /** The error code. */
    code: string;
    /** The message explaining the error reported by the service. */
    message: string;
}

/** Response of getting a model. */
export declare interface AnomalyDetectorClientModel {
    /** Model identifier. */
    modelId: string;
    /** Date and time (UTC) when the model was created. */
    createdTime: Date;
    /** Date and time (UTC) when the model was last updated. */
    lastUpdatedTime: Date;
    /** Train result of a model including status, errors and diagnose info for model and variables. */
    modelInfo?: AnomalyDetectorClientModelInfo;
}

/** Train result of a model including status, errors and diagnose info for model and variables. */
export declare interface AnomalyDetectorClientModelInfo {
    /** An optional field, indicating how many previous points will be used to compute the anomaly score of the subsequent point. */
    slidingWindow?: number;
    alignPolicy?: AlignPolicy;
    /** Source link to the input variables. Each variable should be a csv file with two columns, `timestamp` and `value`. By default, the file name of the variable will be used as its variable name. */
    source: string;
    /** A required field, indicating the start time of training data. Should be date-time. */
    startTime: Date;
    /** A required field, indicating the end time of training data. Should be date-time. */
    endTime: Date;
    /** An optional field. The name of the model whose maximum length is 24. */
    displayName?: string;
    /**
     * Model training status.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly status?: AnomalyDetectorClientModelStatus;
    /**
     * Error messages when failed to create a model.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly errors?: AnomalyDetectorClientErrorResponse[];
    /** NOTE: This property will not be serialized. It can only be populated by the server. */
    readonly diagnosticsInfo?: DiagnosticsInfo;
}

/** Response of listing models. */
export declare interface AnomalyDetectorClientModelList {
    /** List of models */
    models: AnomalyDetectorClientModelSnapshot[];
    /** Current count of trained multivariate models. */
    currentCount: number;
    /** Max number of models that can be trained for this subscription. */
    maxCount: number;
    /** The link to fetch more models. */
    nextLink?: string;
}

export declare interface AnomalyDetectorClientModelSnapshot {
    /** Model identifier. */
    modelId: string;
    /** Date and time (UTC) when the model was created. */
    createdTime: Date;
    /** Date and time (UTC) when the model was last updated. */
    lastUpdatedTime: Date;
    /**
     * Model training status.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly status: AnomalyDetectorClientModelStatus;
    displayName?: string;
    /** Total number of variables. */
    variablesCount: number;
}

export declare interface AnomalyDetectorClientModelState {
    /** Epoch id */
    epochIds?: number[];
    trainLosses?: number[];
    validationLosses?: number[];
    latenciesInSeconds?: number[];
}

/** Defines values for ModelStatus. */
export declare type AnomalyDetectorClientModelStatus = "CREATED" | "RUNNING" | "READY" | "FAILED";

/**
 * Client options used to configure Form Recognizer API requests.
 */
export declare interface AnomalyDetectorClientOptions extends PipelineOptions {
}

export declare interface AnomalyDetectorClientVariableState {
    /** Variable name. */
    variable?: string;
    /** Proportion of NaN values filled of the variable. */
    filledNARatio?: number;
    /** Number of effective points counted. */
    effectiveCount?: number;
    /** Start time of the variable. */
    startTime?: Date;
    /** End time of the variable. */
    endTime?: Date;
}

export declare class AnomalyDetectorContext extends coreHttp.ServiceClient {
    endpoint: string;
    apiVersion: string;
    /**
     * Initializes a new instance of the AnomalyDetectorContext class.
     * @param endpoint Supported Cognitive Services endpoints (protocol and hostname, for example:
     *                 https://westus2.api.cognitive.microsoft.com).
     * @param options The parameter options
     */
    constructor(endpoint: string, options?: AnomalyDetectorOptionalParams);
}

/** Defines headers for AnomalyDetector_deleteMultivariateModel operation. */
export declare interface AnomalyDetectorDeleteMultivariateModelExceptionHeaders {
    /** error code */
    xMsErrorCode?: string;
}

/** Optional parameters. */
export declare interface AnomalyDetectorDeleteMultivariateModelOptionalParams extends coreHttp.OperationOptions {
}

/** Defines headers for AnomalyDetector_detectAnomaly operation. */
export declare interface AnomalyDetectorDetectAnomalyExceptionHeaders {
    /** error code */
    xMsErrorCode?: string;
}

/** Defines headers for AnomalyDetector_detectAnomaly operation. */
export declare interface AnomalyDetectorDetectAnomalyHeaders {
    /** Location and ID of the detection result. */
    location?: string;
}

/** Optional parameters. */
export declare interface AnomalyDetectorDetectAnomalyOptionalParams extends coreHttp.OperationOptions {
}

/** Contains response data for the detectAnomaly operation. */
export declare type AnomalyDetectorDetectAnomalyResponse = AnomalyDetectorDetectAnomalyHeaders & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The parsed HTTP response headers. */
        parsedHeaders: AnomalyDetectorDetectAnomalyHeaders;
    };
};

/** Defines headers for AnomalyDetector_detectChangePoint operation. */
export declare interface AnomalyDetectorDetectChangePointExceptionHeaders {
    /** error code */
    xMsErrorCode?: string;
}

/** Optional parameters. */
export declare interface AnomalyDetectorDetectChangePointOptionalParams extends coreHttp.OperationOptions {
}

/** Contains response data for the detectChangePoint operation. */
export declare type AnomalyDetectorDetectChangePointResponse = DetectChangePointResponse & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The response body as text (string format) */
        bodyAsText: string;
        /** The response body as parsed JSON or XML */
        parsedBody: DetectChangePointResponse;
    };
};

/** Defines headers for AnomalyDetector_detectEntireSeries operation. */
export declare interface AnomalyDetectorDetectEntireSeriesExceptionHeaders {
    /** error code */
    xMsErrorCode?: string;
}

/** Optional parameters. */
export declare interface AnomalyDetectorDetectEntireSeriesOptionalParams extends coreHttp.OperationOptions {
}

/** Contains response data for the detectEntireSeries operation. */
export declare type AnomalyDetectorDetectEntireSeriesResponse = DetectEntireResponse & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The response body as text (string format) */
        bodyAsText: string;
        /** The response body as parsed JSON or XML */
        parsedBody: DetectEntireResponse;
    };
};

/** Defines headers for AnomalyDetector_detectLastPoint operation. */
export declare interface AnomalyDetectorDetectLastPointExceptionHeaders {
    /** error code */
    xMsErrorCode?: string;
}

/** Optional parameters. */
export declare interface AnomalyDetectorDetectLastPointOptionalParams extends coreHttp.OperationOptions {
}

/** Contains response data for the detectLastPoint operation. */
export declare type AnomalyDetectorDetectLastPointResponse = DetectLastPointResponse & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The response body as text (string format) */
        bodyAsText: string;
        /** The response body as parsed JSON or XML */
        parsedBody: DetectLastPointResponse;
    };
};

/** Defines headers for AnomalyDetector_exportModel operation. */
export declare interface AnomalyDetectorExportModelExceptionHeaders {
    /** error code */
    xMsErrorCode?: string;
}

/** Optional parameters. */
export declare interface AnomalyDetectorExportModelOptionalParams extends coreHttp.OperationOptions {
}

/** Contains response data for the exportModel operation. */
export declare type AnomalyDetectorExportModelResponse = {
    /**
     * BROWSER ONLY
     *
     * The response body as a browser Blob.
     * Always `undefined` in node.js.
     */
    blobBody?: Promise<Blob>;
    /**
     * NODEJS ONLY
     *
     * The response body as a node.js Readable stream.
     * Always `undefined` in the browser.
     */
    readableStreamBody?: NodeJS.ReadableStream;
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse;
};

/** Defines headers for AnomalyDetector_getDetectionResult operation. */
export declare interface AnomalyDetectorGetDetectionResultExceptionHeaders {
    /** error code */
    xMsErrorCode?: string;
}

/** Optional parameters. */
export declare interface AnomalyDetectorGetDetectionResultOptionalParams extends coreHttp.OperationOptions {
}

/** Contains response data for the getDetectionResult operation. */
export declare type AnomalyDetectorGetDetectionResultResponse = DetectionResult & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The response body as text (string format) */
        bodyAsText: string;
        /** The response body as parsed JSON or XML */
        parsedBody: DetectionResult;
    };
};

/** Defines headers for AnomalyDetector_getMultivariateModel operation. */
export declare interface AnomalyDetectorGetMultivariateModelExceptionHeaders {
    /** error code */
    xMsErrorCode?: string;
}

/** Optional parameters. */
export declare interface AnomalyDetectorGetMultivariateModelOptionalParams extends coreHttp.OperationOptions {
}

/** Contains response data for the getMultivariateModel operation. */
export declare type AnomalyDetectorGetMultivariateModelResponse = AnomalyDetectorClientModel & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The response body as text (string format) */
        bodyAsText: string;
        /** The response body as parsed JSON or XML */
        parsedBody: AnomalyDetectorClientModel;
    };
};

/** Defines headers for AnomalyDetector_lastDetectAnomaly operation. */
export declare interface AnomalyDetectorLastDetectAnomalyExceptionHeaders {
    /** error code */
    xMsErrorCode?: string;
}

/** Optional parameters. */
export declare interface AnomalyDetectorLastDetectAnomalyOptionalParams extends coreHttp.OperationOptions {
}

/** Contains response data for the lastDetectAnomaly operation. */
export declare type AnomalyDetectorLastDetectAnomalyResponse = LastDetectionResult & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The response body as text (string format) */
        bodyAsText: string;
        /** The response body as parsed JSON or XML */
        parsedBody: LastDetectionResult;
    };
};

/** Defines headers for AnomalyDetector_listMultivariateModel operation. */
export declare interface AnomalyDetectorListMultivariateModelExceptionHeaders {
    /** error code */
    xMsErrorCode?: string;
}

/** Defines headers for AnomalyDetector_listMultivariateModelNext operation. */
export declare interface AnomalyDetectorListMultivariateModelNextExceptionHeaders {
    /** error code */
    xMsErrorCode?: string;
}

/** Optional parameters. */
export declare interface AnomalyDetectorListMultivariateModelNextOptionalParams extends coreHttp.OperationOptions {
    /** $skip indicates how many models will be skipped. */
    skip?: number;
    /** $top indicates how many models will be fetched. */
    top?: number;
}

/** Contains response data for the listMultivariateModelNext operation. */
export declare type AnomalyDetectorListMultivariateModelNextResponse = AnomalyDetectorClientModelList & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The response body as text (string format) */
        bodyAsText: string;
        /** The response body as parsed JSON or XML */
        parsedBody: AnomalyDetectorClientModelList;
    };
};

/** Optional parameters. */
export declare interface AnomalyDetectorListMultivariateModelOptionalParams extends coreHttp.OperationOptions {
    /** $skip indicates how many models will be skipped. */
    skip?: number;
    /** $top indicates how many models will be fetched. */
    top?: number;
}

/** Contains response data for the listMultivariateModel operation. */
export declare type AnomalyDetectorListMultivariateModelResponse = AnomalyDetectorClientModelList & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The response body as text (string format) */
        bodyAsText: string;
        /** The response body as parsed JSON or XML */
        parsedBody: AnomalyDetectorClientModelList;
    };
};

/** Optional parameters. */
export declare interface AnomalyDetectorOptionalParams extends coreHttp.ServiceClientOptions {
    /** Anomaly Detector API version (for example, v1.0). */
    apiVersion?: string;
    /** Overrides client endpoint. */
    endpoint?: string;
}

/** Defines headers for AnomalyDetector_trainMultivariateModel operation. */
export declare interface AnomalyDetectorTrainMultivariateModelExceptionHeaders {
    /** error code */
    xMsErrorCode?: string;
}

/** Defines headers for AnomalyDetector_trainMultivariateModel operation. */
export declare interface AnomalyDetectorTrainMultivariateModelHeaders {
    /** Location and ID of the model. */
    location?: string;
}

/** Optional parameters. */
export declare interface AnomalyDetectorTrainMultivariateModelOptionalParams extends coreHttp.OperationOptions {
}

/** Contains response data for the trainMultivariateModel operation. */
export declare type AnomalyDetectorTrainMultivariateModelResponse = AnomalyDetectorTrainMultivariateModelHeaders & {
    /** The underlying HTTP response. */
    _response: coreHttp.HttpResponse & {
        /** The parsed HTTP response headers. */
        parsedHeaders: AnomalyDetectorTrainMultivariateModelHeaders;
    };
};

export declare interface AnomalyInterpretation {
    variable?: string;
    contributionScore?: number;
    correlationChanges?: CorrelationChanges;
}

export declare interface AnomalyState {
    /** timestamp */
    timestamp: Date;
    value?: AnomalyValue;
    /** Error message for the current timestamp */
    errors?: AnomalyDetectorClientErrorResponse[];
}

export declare interface AnomalyValue {
    /** True if an anomaly is detected at the current timestamp. */
    isAnomaly: boolean;
    /** Indicates the significance of the anomaly. The higher the severity, the more significant the anomaly. */
    severity: number;
    /** Raw score from the model. */
    score: number;
    interpretation?: AnomalyInterpretation[];
}

export declare interface CorrelationChanges {
    /** correlated variables */
    changedVariables?: string[];
    /** changes in correlation */
    changedValues?: number[];
}

/** The request of change point detection. */
export declare interface DetectChangePointRequest {
    /** Time series data points. Points should be sorted by timestamp in ascending order to match the change point detection result. */
    series: TimeSeriesPoint[];
    /** Can only be one of yearly, monthly, weekly, daily, hourly, minutely or secondly. Granularity is used for verify whether input series is valid. */
    granularity: TimeGranularity;
    /** Custom Interval is used to set non-standard time interval, for example, if the series is 5 minutes, request can be set as {"granularity":"minutely", "customInterval":5}. */
    customInterval?: number;
    /** Optional argument, periodic value of a time series. If the value is null or does not present, the API will determine the period automatically. */
    period?: number;
    /** Optional argument, advanced model parameter, a default stableTrendWindow will be used in detection. */
    stableTrendWindow?: number;
    /** Optional argument, advanced model parameter, between 0.0-1.0, the lower the value is, the larger the trend error will be which means less change point will be accepted. */
    threshold?: number;
}

/** The response of change point detection. */
export declare interface DetectChangePointResponse {
    /**
     * Frequency extracted from the series, zero means no recurrent pattern has been found.
     * NOTE: This property will not be serialized. It can only be populated by the server.
     */
    readonly period?: number;
    /** isChangePoint contains change point properties for each input point. True means an anomaly either negative or positive has been detected. The index of the array is consistent with the input series. */
    isChangePoint?: boolean[];
    /** the change point confidence of each point */
    confidenceScores?: number[];
}

/** The response of entire anomaly detection. */
export declare interface DetectEntireResponse {
    /** Frequency extracted from the series, zero means no recurrent pattern has been found. */
    period: number;
    /** ExpectedValues contain expected value for each input point. The index of the array is consistent with the input series. */
    expectedValues: number[];
    /** UpperMargins contain upper margin of each input point. UpperMargin is used to calculate upperBoundary, which equals to expectedValue + (100 - marginScale)*upperMargin. Anomalies in response can be filtered by upperBoundary and lowerBoundary. By adjusting marginScale value, less significant anomalies can be filtered in client side. The index of the array is consistent with the input series. */
    upperMargins: number[];
    /** LowerMargins contain lower margin of each input point. LowerMargin is used to calculate lowerBoundary, which equals to expectedValue - (100 - marginScale)*lowerMargin. Points between the boundary can be marked as normal ones in client side. The index of the array is consistent with the input series. */
    lowerMargins: number[];
    /** IsAnomaly contains anomaly properties for each input point. True means an anomaly either negative or positive has been detected. The index of the array is consistent with the input series. */
    isAnomaly: boolean[];
    /** IsNegativeAnomaly contains anomaly status in negative direction for each input point. True means a negative anomaly has been detected. A negative anomaly means the point is detected as an anomaly and its real value is smaller than the expected one. The index of the array is consistent with the input series. */
    isNegativeAnomaly: boolean[];
    /** IsPositiveAnomaly contain anomaly status in positive direction for each input point. True means a positive anomaly has been detected. A positive anomaly means the point is detected as an anomaly and its real value is larger than the expected one. The index of the array is consistent with the input series. */
    isPositiveAnomaly: boolean[];
    /** The severity score for each input point. The larger the value is, the more sever the anomaly is. For normal points, the "severity" is always 0. */
    severity?: number[];
}

/** Detection request. */
export declare interface DetectionRequest {
    /** Source link to the input variables. Each variable should be a csv with two columns, `timestamp` and `value`. The file name of the variable will be used as its name. The variables used in detection should be exactly the same with those used in the training phase. */
    source: string;
    /** A required field, indicating the start time of data for detection. Should be date-time. */
    startTime: Date;
    /** A required field, indicating the end time of data for detection. Should be date-time. */
    endTime: Date;
}

/** Response of the given resultId. */
export declare interface DetectionResult {
    resultId: string;
    summary: DetectionResultSummary;
    /** Detection result for each timestamp. */
    results: AnomalyState[];
}

export declare interface DetectionResultSummary {
    /** Status of detection results. One of CREATED, RUNNING, READY, and FAILED. */
    status: DetectionStatus;
    /** Error message when detection is failed. */
    errors?: AnomalyDetectorClientErrorResponse[];
    variableStates?: AnomalyDetectorClientVariableState[];
    /** Detection request. */
    setupInfo: DetectionRequest;
}

/** Defines values for DetectionStatus. */
export declare type DetectionStatus = "CREATED" | "RUNNING" | "READY" | "FAILED";

/** The response of last anomaly detection. */
export declare interface DetectLastPointResponse {
    /** Frequency extracted from the series, zero means no recurrent pattern has been found. */
    period: number;
    /** Suggested input series points needed for detecting the latest point. */
    suggestedWindow: number;
    /** Expected value of the latest point. */
    expectedValue: number;
    /** Upper margin of the latest point. UpperMargin is used to calculate upperBoundary, which equals to expectedValue + (100 - marginScale)*upperMargin. If the value of latest point is between upperBoundary and lowerBoundary, it should be treated as normal value. By adjusting marginScale value, anomaly status of latest point can be changed. */
    upperMargin: number;
    /** Lower margin of the latest point. LowerMargin is used to calculate lowerBoundary, which equals to expectedValue - (100 - marginScale)*lowerMargin. */
    lowerMargin: number;
    /** Anomaly status of the latest point, true means the latest point is an anomaly either in negative direction or positive direction. */
    isAnomaly: boolean;
    /** Anomaly status in negative direction of the latest point. True means the latest point is an anomaly and its real value is smaller than the expected one. */
    isNegativeAnomaly: boolean;
    /** Anomaly status in positive direction of the latest point. True means the latest point is an anomaly and its real value is larger than the expected one. */
    isPositiveAnomaly: boolean;
    /** The severity score for the last input point. The larger the value is, the more sever the anomaly is. For normal points, the "severity" is always 0. */
    severity?: number;
}

/** The request of entire or last anomaly detection. */
export declare interface DetectRequest {
    /** Time series data points. Points should be sorted by timestamp in ascending order to match the anomaly detection result. If the data is not sorted correctly or there is duplicated timestamp, the API will not work. In such case, an error message will be returned. */
    series: TimeSeriesPoint[];
    /** Optional argument, can be one of yearly, monthly, weekly, daily, hourly, minutely, secondly, microsecond or none. If granularity is not present, it will be none by default. If granularity is none, the timestamp property in time series point can be absent. */
    granularity?: TimeGranularity;
    /** Custom Interval is used to set non-standard time interval, for example, if the series is 5 minutes, request can be set as {"granularity":"minutely", "customInterval":5}. */
    customInterval?: number;
    /** Optional argument, periodic value of a time series. If the value is null or does not present, the API will determine the period automatically. */
    period?: number;
    /** Optional argument, advanced model parameter, max anomaly ratio in a time series. */
    maxAnomalyRatio?: number;
    /** Optional argument, advanced model parameter, between 0-99, the lower the value is, the larger the margin value will be which means less anomalies will be accepted. */
    sensitivity?: number;
    /** Used to specify how to deal with missing values in the input series, it's used when granularity is not "none". */
    imputeMode?: ImputeMode;
    /** Used to specify the value to fill, it's used when granularity is not "none" and imputeMode is "fixed". */
    imputeFixedValue?: number;
}

export declare interface DiagnosticsInfo {
    modelState?: AnomalyDetectorClientModelState;
    variableStates?: AnomalyDetectorClientVariableState[];
}

/**
 * Defines values for FillNAMethod. \
 * {@link KnownFillNAMethod} can be used interchangeably with FillNAMethod,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **Previous** \
 * **Subsequent** \
 * **Linear** \
 * **Zero** \
 * **Fixed** \
 * **NotFill**
 */
export declare type FillNAMethod = string;

/**
 * Defines values for ImputeMode. \
 * {@link KnownImputeMode} can be used interchangeably with ImputeMode,
 *  this enum contains the known values that the service supports.
 * ### Known values supported by the service
 * **auto** \
 * **previous** \
 * **linear** \
 * **fixed** \
 * **zero** \
 * **notFill**
 */
export declare type ImputeMode = string;

/** Known values of {@link FillNAMethod} that the service accepts. */
export declare const enum KnownFillNAMethod {
    Previous = "Previous",
    Subsequent = "Subsequent",
    Linear = "Linear",
    Zero = "Zero",
    Fixed = "Fixed",
    NotFill = "NotFill"
}

/** Known values of {@link ImputeMode} that the service accepts. */
export declare const enum KnownImputeMode {
    Auto = "auto",
    Previous = "previous",
    Linear = "linear",
    Fixed = "fixed",
    Zero = "zero",
    NotFill = "notFill"
}

export declare enum KnownTimeGranularity {
    /**
     * Yearly time granularity
     */
    yearly = "yearly",
    /**
     * Monthly time granularity
     */
    monthly = "monthly",
    /**
     * Weekly time granularity
     */
    weekly = "weekly",
    /**
     * Daily time granularity
     */
    daily = "daily",
    /**
     * Hourly time granularity
     */
    hourly = "hourly",
    /**
     * Per minute time granularity
     */
    perMinute = "minutely",
    /**
     * Per second time granularity
     */
    perSecond = "secondly",
    /**
     * Per microsecond time granularity
     */
    perMicrosecond = "microsecond",
    /**
     * None
     */
    none = "none"
}

export declare interface LastDetectionRequest {
    /** variables */
    variables: VariableValues[];
    /** number of timestamps on which the model detects */
    detectingPoints: number;
}

export declare interface LastDetectionResult {
    variableStates?: AnomalyDetectorClientVariableState[];
    results?: AnomalyState[];
}

/** Defines values for TimeGranularity. */
export declare type TimeGranularity = "yearly" | "monthly" | "weekly" | "daily" | "hourly" | "minutely" | "secondly" | "microsecond" | "none";

/** The definition of input timeseries points. */
export declare interface TimeSeriesPoint {
    /** Optional argument, timestamp of a data point (ISO8601 format). */
    timestamp?: Date;
    /** The measurement of that point, should be float. */
    value: number;
}

export declare interface VariableValues {
    /** variable name */
    name: string;
    /** timestamps */
    timestamps: string[];
    /** values */
    values: number[];
}

export { }
